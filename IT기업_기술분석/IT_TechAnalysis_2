 

; 📌 IT 기업 기술 블로그 분석

; — 문제 정의 방식 관점에서 바라보기

 
; ✍️ 분석 목적

; 이 팀은 문제를 어떻게 정의했고,

; 왜 이 해결책을 선택했는가?

; 출처 입력

; 기술 자체를 배우기보다는,

; 문제를 인식하고 정의하는 사고 과정을 이해하는 것을 목표로 한다.

; 🔍 분석 대상

; 기업 / 팀: 우아한 형제들 기술 블로그
; 글 제목: 배달의 민족 주문접수 채널에 Flutter를 도입하며 고민한 것
; 작성 연도: 2025년 12월 16일
; 다루는 주제: 프로그래밍
; ① 문제는 어디서 시작됐는가?

; 이 글에서 문제는 어떤 계기로 등장했는가?

; 주문채널이 점차 다양한 디바이스로 확장
; macOS 데스크톱, Android 태블릿, POS 등 새로운 디바이스 요구 빠르게 증가
; 매일 수백만 건의 주문을 실시간 처리하는 환경
; 디바이스가 늘어날수록 추가 개발 리드타임이 비즈니스 속도를 따라가지 못함
; 👉 **문제의 ‘출발점’**은 무엇이었는지 정리한다.

; ② 왜 이게 ‘문제’라고 판단했는가?

; 단순한 불편이 아니라,

; 왜 반드시 해결해야 할 문제라고 판단했는가?

; 비즈니스 확장 자체를 제한하는 문제
; 플랫폼 별로 같은 기능 반복 구현
; 신규 디바이스 대응 속도가 비즈니스 요구를 따라가지 못함
; 개발자가 플랫폼 별로 분리됨
; 개발 리소스가 확장될수록 비용이 선형 이상으로 증가 - 대응 지연
; 👉 ‘문제’와 ‘현상’을 구분하는 기준에 집중한다.

; ③ 문제를 어떻게 쪼갰는가?

; 하나의 큰 문제를

; 어떤 기준으로 분해했는가?

; 플랫폼 확장 문제
; 새로운 디바이스 추가될 때마다 개발/배포 비용 기하급수적으로 증가
; 개발 생산성 문제
; 동일한 기능을 여러 플랫폼에 반복 구현하면서 개발 속도 저하
; 유지보수 및 품질 문제
; 플랫폼 간 기능/UX 불일치로 버그와 운영 리스크 증가
; 👉 문제를 관리 가능한 단위로 나누는 방식을 본다.

; ④ 대안은 무엇이 있었는가?

; 현재 선택한 해결책 외에

; 고려했던 다른 선택지는 무엇이었는가?

; 대안 검토 기준
; 단일 코드 베이스로 여러 플랫폼을 지원할 수 있는지
; 장기적인 플랫폼 확장에 대응 가능한 구조인지
; 테스트 가능성과 유지보수성을 확보할 수 있는지
; 팀의 학습 비용이 과도하지 않은지
; 전략: Flutter 도입
; Windows, Android, iOS, macOS 모두 지원하며 단일 코드 베이스 조건을 만족하는 성숙한 생태계를 갖춘 프레임워크는 Flutter가 유일
; 한계:
; 플랫폼 별 주변 기기 제어, 권한 시스템, 알림 방식, 업데이트 등 메커니즘 다른 부분들 존재
; 해결:
; 각 플랫폼의 업데이트 방식이 완전히 다르지만, 비즈니스 로직에서는 "업데이트 확인 및 실행"이라는 하나의 인터페이스로 통일할 수 있었음
; 플랫폼 별 구현이 다르거나 외부 라이브러리에 의존하며 교체 가능성이 있거나 테스트를 위해 Mock이 필요한 경우 추상화 진행
; 아키텍처: Clean Architecture + BLoc
; 계층 분리로 충분한 관심사 분리
; UI 프레임워크 교체 가능성과 테스트 가능성 확보
; 인터페이스 기반 계층 분리로 플랫폼 독립성 유지하면서 유지보수성 향상
; 팀의 학습 곡선이 완만함
; BLoc
; 로그를 통해 명확한 상태 추적 가능
; 버그 디버깅 시간 단축
; 화면 단위로 단일 책임 원칙 적용
; 코드량보다 유지보수성과 명확한 상태 관리를 우선
; 대안1. BLoc 패턴이나 MVVM + Provider
; Flutter 프로젝트에서는 주로 사용하는 패턴
; but,
; 플랫폼 확장과 큰 변경을 대비하여 계층 분리가 명확할 필요가 있음
; 계층 분리가 상대적으로 느슨한 패턴은 장기적으로 비즈니스 요구 변화에 취약하다 판단
; 👉 “왜 이 방법만 있었는가?”가 아니라

; **“왜 다른 방법은 선택되지 않았는가?”**에 집중한다.

; ⑤ 왜 이 해결책을 선택했는가?

; 최종 선택의 판단 기준은 무엇이었는가?

; 이 팀에서 가장 우선시된 기준
; 장기적인 플랫폼 확장성과 구조적 안정성
; 선택한 해결책
; 플랫폼 수가 계속 증가하는 상황에서 동일한 기능을 반복 구현하는 방식은 더 이상 지속 불가능
; 플랫폼 별 차이를 흡수할 수 있는 구조 필요
; Flutter는 단일 코드 베이스로 여러 플랫폼 지원 가능
; Clean Architecture를 통해 플랫폼 의존적 구현을 분리
; 비즈니스 로직 안정적으로 유지 가능
; BLoc 패턴으로 상태 흐름을 명확히 드러내 대규모 주문 처리 환경에서도 디버깅과 유지보수 용이
; 이 선택은 특정 기술을 선호해서가 아니라, 확장되는 비즈니스 요구를 가장 현실적으로 감당할 수 있는 구조였기 때문에 내려진 결정이었다.
; 👉 기술 그 자체보다

; 선택의 기준과 우선순위를 파악한다.

; ⑥ 결과를 어떻게 검증했는가?

; 해결책 적용 후,

; 문제가 실제로 해결되었음을 어떻게 확인했는가?

; 문제 기준의 충족 여부 검증
; 플랫폼 확장에 따른 개발 및 비용 증가
; 신규 디바이스 추가 시, 비즈니스 로직 수정없이 플랫폼 계층만 구현하고, 기능 변경 또한 단일 베이스에서 반영할 수 있는 구조가 되었음을 확인할 수 있음
; 실제 개발 과정에서 공통 로직을 중심으로 논의가 이루어졌고, 상태 변화는 BLoc 로그를 통해 추적 가능
; 정량적인 수치를 확보한 단계는 아니지만, 문제를 다시 겪지 않도록 구조를 바꿨고 이제는 그 효과를 측정할 수 있는 상태가 됨
; 👉 *“잘 된 것 같다”*가 아니라

; 어떻게 ‘증명’했는지를 본다.

; 🧠 분석을 통해 얻은 인사이트

; 이 글을 통해 배운 문제 정의 방식은 무엇인가?

; 이번 분석을 통해, 문제 해결의 효과가 반드시 정량 지표로만 드러나지 않더라도 비즈니스 관점에서 문제를 명확히 정의하는 것만으로도 구현 단계에서 발생하는 불필요한 시간과 비용을 줄일 수 있음을 확인했다.
; 또한 단기적인 구현 효율뿐 아니라, 향후 발생할 수 있는 유사한 문제에 구조적으로 대응할 수 있는 미래 지향적인 해결책 역시 중요한 결과 중 하나임을 알 수 있었다. 특히 대안을 검토하는 과정에서 팀의 학습 곡선을 판단 기준으로 삼은 점은 이전에는 충분히 고려하지 않았던 요소였지만, 장기적인 유지보수와 조직의 생산성을 위해 매우 중요한 기준임을 이해하게 되었다.
; 🔁 내 관점에서의 정리

; 이 방식을 내 분석/업무에 적용한다면?

; 출처 입력

; 이 글을 통해 기술 선택을 바라보는 관점이 더욱 분명해졌다. 프레임워크나 아키텍처는 유행이나 관습이 아니라 비즈니스 구조와 요구사항에 맞게 선택되어야 하며, 특히 플랫폼 확장 상황에서는 일반적인 구조보다 문제 해결에 적합한 아키텍처를 선택하는 것이 중요하다는 점을 인식하게 되었다. 무엇보다 기술 선택의 출발점은 기술 자체가 아니라 문제를 얼마나 정확하게 정의했는가에 달려 있으며, 기술 도입의 목적은 변화하는 요구에 지속적으로 대응할 수 있는 구조를 만드는 데 있다는 점이 인상 깊었다.

; ✅ 마무리 한 줄 요약

; 이 글에서 가장 인상 깊었던 문제 정의 포인트 한 가지

; 출처 입력

; 이 글은 문제 정의를 ‘플랫폼 증가’가 아니라 ‘플랫폼 확장이 반복 구현과 조직 분리를 초래해 비즈니스 대응 속도를 저하시킨 구조적 불일치’로 정의한 점이 가장 인상 깊었다.