; 📌 IT 기업 기술 블로그 분석
; — 문제 정의 방식 관점에서 바라보기
; ✍️ 분석 목적
; 이 팀은 문제를 어떻게 정의했고,
; 왜 이 해결책을 선택했는가?

; 기술 자체를 배우기보다는,
; 문제를 인식하고 정의하는 사고 과정을 이해하는 것을 목표로 한다.
; 🔍 분석 대상
; 기업 / 팀: 당근 테크 블로그
; 글 제목: 웹뷰 엔지니어를 위한 iOS Webview Input 경험 개선
; 작성 연도: 2026년 2월 23일
; 다루는 주제: iOS Webview 환경에서의 Input UX 개선
; ① 문제는 어디서 시작됐는가?
; 이 글에서 문제는 어떤 계기로 등장했는가?
; iOS에서 키보드가 올라올 때 화면이 밀리는 문제가 있음
; 커뮤니티 서비스인 만큼 유저의 입력 경험이 핵심 인터렉션
; 화면이 밀리는 문제는 유저의 흐름을 쉽게 끊음
; 👉 **문제의 ‘출발점’**은 무엇이었는지 정리한다.
; ② 왜 이게 ‘문제’라고 판단했는가?
; 단순한 불편이 아니라,
; 왜 반드시 해결해야 할 문제라고 판단했는가?
; 사용자는 입력을 하는 순간에 맥락을 유지한채 타이핑하길 기대함
; 화면이 밀리며 콘텐츠가 사라지면 인지 부담이 발생
; 입력 흐름이 깨지는 사용자 경험의 붕괴 발
; 👉 ‘문제’와 ‘현상’을 구분하는 기준에 집중한다.
; ③ 문제를 어떻게 쪼갰는가?
; 하나의 큰 문제를
; 어떤 기준으로 분해했는가?
; OS 동작
; iOS의 scroll-into-view 동작에 대한 대응 필요
; 개발자의 제어 가능 영역 확인
; focus 대상과 스타일 제어 가능
; 스크롤 결과 제어 불가
; 👉 문제를 관리 가능한 단위로 나누는 방식을 본다.
; ④ 대안은 무엇이 있었는가?
; 현재 선택한 해결책 외에
; 고려했던 다른 선택지는 무엇이었는가?
; 전략: input의 Opacity 조절
; 해결책:
; iOS는 opacity가 0인 요소에 대해 scroll-into-view 수행하지 않음을 확인
; input을 터치하는 순간 opacity를 0으로 만들고, 키보드라 올라오면 1로 복원
; 대안 1: visual Viewport의 resize
; 키보드 높이만큼 wrapper 축소
; window.scrollTo(0,0)으로 밀린 스크린 되돌리기
; 문제:
; scrollTo가 호출되기 전 이미 화면이 밀려 올라감
; 사용자 눈에 화면이 위로 밀렸다가 다시 내려오는 깜빡임이 보임
; resize 이벤트가 여러번 발생할 경우 화면 떨림 현상 있음
; 대안 2: visualViewport.offsetTop만큼 이동시키기
; offsetTop(화면이 얼마나 밀렸는지 알려주는 값)만큼 wrapper의 top을 같이 내려줌
; 시각적으로는 콘텐츠가 제자리에 있는 것처럼 보임
; 문제:
; offsetTop을 실시간으로 따라가다 보니, 키보드가 올라오는 동안 wrapper가 계속 위치를 조정하여 미세한 떨림이 있었음
; 유저가 여러 input을 빠르게 탭하거나 키보드를 접었다 폈다 하면 화면이 계속 흔들려서 어지럽다는 피드백도 있었음
; 대안 3: FakeInputSwap 추가
; iOS는 focus된 input을 키보드 위로 보이게 하기 위해 화면을 밀어올림
; focus 받는 input을 화면 밖에 둔다면 iOS가 의미있는 스크롤을 할 수 없음
; 사용자에게 보이는 Fake Input과 화면 밖의 RealInput 준비
; 키보드가 올라온 후 두 input을 swap하면 자연스럽게 입력 가능
; 문제:
; 가상 키보드의 height보다 더 위에 input이 보였다 움직이는 작은 이슈 있음
; input이 2개다 보니 value, selection, placeholder 같은 상태 지속적인 동기화 필요
; swap 시점의 미세한 깜빡임 존재
; 키보드가 올라왔는지 정확한 감지 어려움
; 네이티브 브릿지에 의존하는 등 로직이 복잡해짐
; 👉 “왜 이 방법만 있었는가?”가 아니라
; **“왜 다른 방법은 선택되지 않았는가?”**에 집중한다.
; ⑤ 왜 이 해결책을 선택했는가?
; 최종 선택의 판단 기준은 무엇이었는가?
; 이 팀에서 가장 우선시된 기준
; 유저의 사용 경험에 방해가 없어야 함
; 선택한 해결책
; scroll-into-view가 동작하지 않는 방법으로 opacity:0에서 1로 설정
; input 하나만 사용하여 동기화가 없고, 화면 밀림 현상이 없음
; 👉 기술 그 자체보다
; 선택의 기준과 우선순위를 파악한다.
; ⑥ 결과를 어떻게 검증했는가?
; 해결책 적용 후,
; 문제가 실제로 해결되었음을 어떻게 확인했는가?
; 화면 밀림이 시각적으로 사라짐
; 입력 중 컨텐츠 인지 유지
; 유저가 어지럽지 않다는 피드백이 중요한 검증 지표라고 볼 수 있음
; 👉 *“잘 된 것 같다”*가 아니라
; 어떻게 ‘증명’했는지를 본다.
; 🧠 분석을 통해 얻은 인사이트
; 이 글을 통해 배운 문제 정의 방식은 무엇인가?
; 이 글을 통해 느낀 핵심 인사이트는, 문제의 크기가 아니라 유저 경험에 미치는 영향의 크기로 문제를 판단한다는 점이다. 이 팀에서는 화면 밀림이라는 현상을 단순한 기술적 제약으로 받아들이지 않고, 입력 흐름을 방해하는 사용자 경험의 단절로 재정의했다. 완성도 높은 설계나 이상적인 구현보다, 유저가 불편함 없이 서비스를 이용할 수 있는가를 최우선 기준으로 삼아 여러 대안을 검토하고 가장 안정적인 해결책을 선택한 문제 정의 방식이 인상 깊었다.
; 🔁 내 관점에서의 정리
; 이 방식을 내 분석/업무에 적용한다면?

; 이번 분석을 통해 문제 정의에 대한 나의 기준도 달라졌다. 이전에는 문제 정의를 거창한 구조 개선이나 복잡한 설계 변경으로만 생각했지만, 실제로는 작은 인터랙션 하나가 사용자 경험 전체를 무너뜨릴 수 있다는 점이 더 중요하다는 것을 깨달았다.
; 이 사례처럼, 기술적 한계를 이유로 불편을 받아들이기보다 유저의 입장에서 불편을 다시 문제로 정의하고, 현실적인 제약 안에서 최선의 해결책을 찾는 과정이 곧 문제 해결의 본질이라고 생각하게 되었다.
; 앞으로 나의 업무에서도 이러한 관점으로 작은 불편을 놓치지 않고, 지속적으로 개선 지점을 찾아 나가고자 한다.
; ✅ 마무리 한 줄 요약
; 이 글에서 가장 인상 깊었던 문제 정의 포인트 한 가지

; 기술의 한계보다 유저 경험을 기준으로 문제를 정의하고, 가장 현실적인 방식으로 사용자의 흐름을 지켜냈다.

